 The author utilizes mathematical notation rather than suffering through the inevitable inadequacies and limitations of any particular language (LISP, ML, Haskell, ..) However this actually simplifies the instruction,  assuming the reader is familiar with set theory and the basics of formal  logic. The illustrations are primarily of the kind familiar to anyone  involved in computer science, such as parse trees, flowcharts, and  schematics of memory allocation. There are also mathematical type  signatures. Program examples include [very] infrequent ones in LISP, as  well as occasional procedural examples given in antiquated-yet-adequate  Pascal. For the purpose of general instruction this may well be  unexcelled in the field. Upon completion the reader will have a better  underlying understanding of any particular functional language than peers  who have been programming in one ad-hoc for a substantially longer time.  Many of the general topics are fundamental to other language paradigms as  well, including procedural and object-orientation (of which the author is  an expert and contributor). Of particular note are the topics of recursion,  binding, and computability issues, as discussed using the lambda  calculus. This is an extremely clear work, systematically covering  subjects ranging through logic, computing and math without drawing any  attention to distinctions between them. Throughout, it maintains a complete  focus upon functional programming. In this way there is a satisfying flow  to the book, allowing the incredibly rich and fine detail to be better  understood in context. It is important to take note that this work does  not merely teach the reader about programming in a functional language.  Many tangent subjects will become familiar in the process, including some  which may have previously been a source of intimidation. And, as  programming languages evolve, such a foundation will prove over time to be  an invaluable resource.     