 Pro: (1) Each chapter begins with a practical example. For example, the chapter computing intersections of lines starts with a discussion of a map-making application that goes into enough detail to see how the algorithms they present would be useful. This is a considerable step up from the common practice in algorithms literature of motivation by way of vaguely mentioning some related field (i.e. "These string matching algorithms are useful in computational biology"). This book does a much better job of motivating the material it presents, but if you're primarily interested in the abstract problem, these sections can be skipped. (2) Each chapter is relatively self-contained. Feel free to skip ahead to subjects that interest you. (3) Surprisingly readable. Unlike most technical material, one can read an entire chapter in a single sitting without missing much. Generally, each chapter will develop a single algorithm for a single kind of problem. (4) It's very up to date. This second edition is less than two years old, it includes some new results in the field. Con: (1) Algorithms are only given in pseudocode. The emphasis is on describing algorithms and data structures clearly and completely. If you're looking for a "cookbook" with code to copy and paste into an application, perhaps O'Rourke's "Computational Geometry in C" would be a better choice. (2) There are many important advanced results that are not discussed in the main text. An obvious example is the first chapter, which describes a well-known convex hull algorithm that takes O(n log n) time but algorithms that are faster for most inputs are mentioned only in the "Notes and Comments" at the end of the chapter. Someone interested in lots of gory details would be well-served to combine this book with Boissonnat and Yvinec's more detailed and mathematical "Algorithmic Geometry".     